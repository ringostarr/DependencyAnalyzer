<!DOCTYPE html><html><head>
<!-------------HTML Prologue------------!>
<!---Published By: Akshay , 708 S Beech Street , Syracuse .--!>
<!----------------------(315)-289-0056----------------------!>
<!----Package Name:C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\AbstractSyntaxTree\AbstractSyntaxTree.h-----!>
<!-------Published on :04:04:2017 15:33:27-----!>
<link rel=stylesheet type=text/css href="./../Stylesheet.css"/></head> <div class = indent><h4>Dependencies:</h4><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\Executive.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\Executive.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\GrammerHelpers\GrammerHelpers.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\GrammerHelpers\GrammerHelpers.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\DepAnal.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\DepAnal.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\Executive.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\Executive.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\ActionsAndRules.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\ActionsAndRules.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\ConfigureParser.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\ConfigureParser.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\Parser.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\Parser.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\ScopeStack\ScopeStack.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\ScopeStack\ScopeStack.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\SemiExp\itokcollection.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\SemiExp\itokcollection.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\SemiExp\SemiExp.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\SemiExp\SemiExp.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Tokenizer.h\Tokenizer.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Tokenizer.h\Tokenizer.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Tokenizer.h\Tokenizer.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Tokenizer.h\Tokenizer.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\XmlDocument\ITokCollection.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\XmlDocument\ITokCollection.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\AbstractSyntaxTree\AbstractSyntaxTree.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\AbstractSyntaxTree\AbstractSyntaxTree.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\FileMgr\FileSystem.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\FileMgr\FileSystem.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\GrammerHelpers\GrammerHelpers.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\GrammerHelpers\GrammerHelpers.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\ScopeStack\ScopeStack.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\ScopeStack\ScopeStack.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\StrongComponent\StComponent.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\StrongComponent\StComponent.h</a><br> </div></hr><pre>#pragma once
/////////////////////////////////////////////////////////////////////
//  AbstrSynTree.h - Represents an Abstract Syntax Tree            //
//  ver 1.3                                                        //
//  Language:      Visual C++ 2015                                 //
//  Platform:      Dell XPS 8900, Windows 10                       //
//  Application:   Used to support parsing source code             //
//  Author:        Jim Fawcett, CST 4-187, Syracuse University     //
//                 (315) 443-3948, jfawcett@twcny.rr.com           //
/////////////////////////////////////////////////////////////////////
/*
Package Operations:
==================
This package defines an AbstrSynTree class and an ASTNode struct.
Those provides support for building Abstract Syntax Trees during
static source code analysis.

Public Interface:
=================
AbstrSynTree ast(scopeStack);       // create instance, passing in ScopeStack
ASTNode* pNode = ast.root();        // get or set root of AST
ast.add(pNode);                     // add ASTNode to tree, linked to current scope
ASTNode* pNode = ast.find(myType);  // retrieve ptr to ASTNode representing myType
ast.pop();                          // close current scope by poping top of scopeStack

Build Process:
==============
Required files
- AbstrSynTree.h, AbstrSynTree.cpp, Utilities.h, Utilities.cpp

Build commands (either one)
- devenv oodp26.sln
- cl /EHsc /DTEST_ABSTRSYNTREE AbstrSynTree.cpp Utilities.cpp /link setargv.obj

Maintenance History:
====================
ver 1.3 : 29 Oct 2016
- added throw in ScopeStack if pop or peek empty stack
ver 1.2 : 28 Oct 2016
- added test for interface in show() and Add(ASTNode*)
ver 1.1 : 22 Aug 2016
- added access type and declaration type enumerations
- added processing to store access level in AST
- added more prologue comments
ver 1.0 : 05 Aug 2016
- first release

*/

#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;
#include &lt;unordered_map&gt;
#include &lt;functional&gt;
#include "../SemiExp/itokcollection.h"
#include "../ScopeStack/ScopeStack.h"

namespace CodeAnalysis
<details><summary>{</summary>
	enum Access
<details><summary>	{</summary>
		publ, prot, priv
</details>	};

	enum DeclType
<details><summary>	{</summary>
		dataDecl, functionDecl, lambdaDecl, usingDecl
</details>	};

	struct DeclarationNode
<details><summary>	{</summary>
		Scanner::ITokCollection* pTc = nullptr;
		Access access_;
		DeclType declType_;
		std::string package_;
		size_t line_;
</details>	};

	struct ASTNode
<details><summary>	{</summary>
		using Type = std::string;
		using Name = std::string;
		using Package = std::string;
		using Path = std::string;

		ASTNode();
		ASTNode(const Type& type, const Name& name);
		~ASTNode();
		Type type_;
		Name name_;
		Package package_;
		Path path_;
		std::string parenttype_;
		size_t startLineCount_;
		size_t endLineCount_;
		size_t complexity_;
		std::vector&lt;ASTNode*&gt; children_;
		std::vector&lt;DeclarationNode&gt; decl_;
		std::vector&lt;Scanner::ITokCollection*&gt; statements_;
		std::string show(bool details = false);
</details>	};

	class AbstrSynTree
<details><summary>	{</summary>
	public:
		using ClassName = std::string;
		using TypeMap = std::unordered_map&lt;ClassName, ASTNode*&gt;;

		AbstrSynTree(ScopeStack&lt;ASTNode*&gt;& stack);
		~AbstrSynTree();
		ASTNode*& root();
		void add(ASTNode* pNode);
		ASTNode * findRecursively(const ClassName & type, ASTNode * node);
		ASTNode* find(const ClassName& type);
		ASTNode* pop();
		TypeMap& typeMap();
	private:
		TypeMap typeMap_;
		ScopeStack&lt;ASTNode*&gt;& stack_;
		ASTNode* pGlobalNamespace_;
</details>	};
	//----&lt; traverse AST and execute callobj on every node &gt;-------------

	template &lt;typename CallObj&gt;
	void ASTWalk(ASTNode* pItem, CallObj co)
<details><summary>	{</summary>
		static size_t indentLevel = 0;
		co(pItem, indentLevel);
		auto iter = pItem-&gt;children_.begin();
		++indentLevel;
		while (iter != pItem-&gt;children_.end())
<details><summary>		{</summary>
			ASTWalk(*iter, co);
			++iter;
</details>		}
		--indentLevel;
</details>	}
	//----&lt; traverse AST and execute callobj on every node &gt;-------------

	template &lt;typename CallObj&gt;
	void ASTWalkNoIndent(ASTNode* pItem, CallObj co)
<details><summary>	{</summary>
		co(pItem);
		auto iter = pItem-&gt;children_.begin();
		while (iter != pItem-&gt;children_.end())
<details><summary>		{</summary>
			ASTWalkNoIndent(*iter, co);
			++iter;
</details>		}
</details>	}
	//----&lt; compute complexities for each ASTNode &gt;--------------------

	inline void complexityWalk(ASTNode* pItem, size_t& count)
<details><summary>	{</summary>
		size_t inCount = ++count;
		auto iter = pItem-&gt;children_.begin();
		while (iter != pItem-&gt;children_.end())
<details><summary>		{</summary>
			complexityWalk(*iter, count);
			++iter;
</details>		}
		pItem-&gt;complexity_ = count - inCount + 1;
</details>	}
	//----&lt; compute complexities for each ASTNode &gt;--------------------

	inline void complexityEval(ASTNode* pNode)
<details><summary>	{</summary>
		size_t initialCount = 0;
		complexityWalk(pNode, initialCount);
</details>	}
</details>}

<details><summary>struct foobar {</summary>

</details>};
</pre></body></html>
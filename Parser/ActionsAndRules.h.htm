<!DOCTYPE html><html><head>
<!-------------HTML Prologue------------!>
<!---Published By: Akshay , 708 S Beech Street , Syracuse .--!>
<!----------------------(315)-289-0056----------------------!>
<!----Package Name:C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\ActionsAndRules.h-----!>
<!-------Published on :04:04:2017 15:33:49-----!>
<link rel=stylesheet type=text/css href="./../Stylesheet.css"/></head> <div class = indent><h4>Dependencies:</h4><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\Executive.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\Executive.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\AbstractSyntaxTree\AbstractSyntaxTree.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\AbstractSyntaxTree\AbstractSyntaxTree.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\GrammerHelpers\GrammerHelpers.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\GrammerHelpers\GrammerHelpers.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\DepAnal.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\DepAnal.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\Executive.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\Executive.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\ConfigureParser.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\ConfigureParser.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\Parser.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\Parser.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\ScopeStack\ScopeStack.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\ScopeStack\ScopeStack.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Logger\Logger.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Logger\Logger.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\GrammerHelpers\GrammerHelpers.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\GrammerHelpers\GrammerHelpers.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\Parser.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Parser\Parser.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\FileMgr\FileSystem.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\FileMgr\FileSystem.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\AbstractSyntaxTree\AbstractSyntaxTree.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\AbstractSyntaxTree\AbstractSyntaxTree.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\SemiExp\itokcollection.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\SemiExp\itokcollection.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\SemiExp\SemiExp.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\SemiExp\SemiExp.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Tokenizer.h\Tokenizer.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Tokenizer.h\Tokenizer.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Tokenizer.h\Tokenizer.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Tokenizer.h\Tokenizer.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\XmlDocument\Tokenizer.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\XmlDocument\Tokenizer.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\FileMgr\FileMgr.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\FileMgr\FileMgr.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\XmlDocument\ITokCollection.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\XmlDocument\ITokCollection.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\ScopeStack\ScopeStack.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\ScopeStack\ScopeStack.cpp</a><br> </div></hr><pre>#ifndef ACTIONSANDRULES_H
#define ACTIONSANDRULES_H
#pragma once
/////////////////////////////////////////////////////////////////////
//  ActionsAndRules.h - declares new parsing rules and actions     //
//  ver 3.2                                                        //
//  Language:      Visual C++ 2008, SP1                            //
//  Platform:      Dell Precision T7400, Vista Ultimate SP1        //
//  Application:   Prototype for CSE687 Pr1, Sp09     
//  Author:        Akshay , 708,S beech streeet Syracuse.
//                  (315)2890056 , akshay@syr.edu
//  Reference:        Jim Fawcett, CST 4-187, Syracuse University  //
//                 (315) 443-3948, jfawcett@twcny.rr.com           //
/////////////////////////////////////////////////////////////////////
/*
Module Operations:
==================
This module defines several action classes.  Its classes provide
specialized services needed for specific applications.  The modules
Parser, SemiExpression, and Tokenizer, are intended to be reusable
without change.  This module provides a place to put extensions of
these facilities and is not expected to be reusable.

Public Interface:
=================
Toker t(someFile);              // create tokenizer instance
SemiExp se(&t);                 // create a SemiExp attached to tokenizer
Parser parser(se);              // now we have a parser
Rule1 r1;                       // create instance of a derived Rule class
Action1 a1;                     // create a derived action
r1.addAction(&a1);              // register action with the rule
parser.addRule(&r1);            // register rule with parser
while(se.getSemiExp())          // get semi-expression
parser.parse();               //   and parse it

Build Process:
==============
Required files
- Parser.h, Parser.cpp, ScopeStack.h, ScopeStack.cpp,
ActionsAndRules.h, ActionsAndRules.cpp, ConfigureParser.cpp,
ItokCollection.h, SemiExpression.h, SemiExpression.cpp, tokenizer.h, tokenizer.cpp
Build commands (either one)
- devenv oodp26.sln
- cl /EHsc /DTEST_PARSER parser.cpp ActionsAndRules.cpp \
semiexpression.cpp tokenizer.cpp /link setargv.obj

Maintenance History:
====================
ver 4.0 : 28th February,2017
- Added enums , typedefs and aliases to AST
ver 3.2 : 28 Aug 16
- fixed errors in many rules and actions based on lots of testing
- cleaned up text, removing comments and improving prologues
ver 3.1 : 23 Aug 16
- qualified input pointers in rules and actions as const
- cleaned up code by removing unreachables and commented code, and by simplifying
ver 3.0 : 06 Aug 16
- Added use of AbstrSynTree
- Added new rules and actions
- Renamed and modified most of the other actions and rules
ver 2.1 : 15 Feb 16
- small functional change to a few of the actions changes display strategy
- preface the (new) Toker and SemiExp with Scanner namespace
ver 2.0 : 01 Jun 11
- added processing on way to building strong code analyzer
ver 1.1 : 17 Jan 09
- changed to accept a pointer to interfaced ITokCollection instead
of a SemiExpression
ver 1.0 : 12 Jan 06
- first release

Planned Changes:
================
C++ lambda detection needs strengthening
*/
//
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include "Parser.h"
#include "../GrammerHelpers/GrammerHelpers.h"
#include "../SemiExp/itokcollection.h"
#include "../ScopeStack/ScopeStack.h"
#include "../Tokenizer.h/Tokenizer.h"
#include "../SemiExp/SemiExp.h"
#include "../AbstractSyntaxTree/AbstractSyntaxTree.h"
#include "../Logger/Logger.h"
#include "../FileMgr/FileSystem.h"

namespace CodeAnalysis
<details><summary>{</summary>
	///////////////////////////////////////////////////////////////////
	// Repository instance is used to share resources
	// among all actions.

	enum Language { C /* not implemented */, Cpp, CSharp };

	class Repository  // application specific
<details><summary>	{</summary>
	public:
		using Rslt = Logging::StaticLogger&lt;0&gt;;  // use for application results
		using Demo = Logging::StaticLogger&lt;1&gt;;  // use for demonstrations of processing
		using Dbug = Logging::StaticLogger&lt;2&gt;;  // use for debug output
		using Package = std::string;
		using Path = std::string;

	private:
		Language language_ = Language::Cpp;
		Path path_;
		ScopeStack&lt;ASTNode*&gt; stack;
		AbstrSynTree ast;
		ASTNode* pGlobalScope;
		Package package_;
		Scanner::Toker* p_Toker;
		Access currentAccess_ = Access::publ;
		static Repository* instance;
		std::string nsname;
	public:
		void setnsname(std::string ns) { nsname = ns; }
		std::string getnsname() { return nsname; }
		Repository(Scanner::Toker* pToker) : ast(stack)
<details><summary>		{</summary>
			p_Toker = pToker;
			pGlobalScope = stack.top();
			instance = this;
</details>		}

		~Repository()
<details><summary>		{</summary>
			Dbug::write("\n  deleting repository");
</details>		}

		Language& language() { return language_; }

		Package& package() { return package_; }

		Path& currentPath() { return path_; }

		Access& currentAccess() { return currentAccess_; }

		static Repository* getInstance() { return instance; }

		ScopeStack&lt;ASTNode*&gt;& scopeStack() { return stack; }

		AbstrSynTree& AST() { return ast; }

		ASTNode* getGlobalScope() { return pGlobalScope; }

		Scanner::Toker* Toker() { return p_Toker; }

		size_t lineCount()
<details><summary>		{</summary>
			return (size_t)(p_Toker-&gt;currentLineCount());
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// rule to detect beginning of scope

	class BeginScope : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Test begin scope", *pTc);

			// don't parse SemiExp with single semicolon token

			if (pTc-&gt;length() == 1 && (*pTc)[0] == ";")
				return IRule::Stop;

<details><summary>			if (pTc-&gt;find("{") &lt; pTc-&gt;length())</summary>
<details><summary>			{</summary>
				doActions(pTc);
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to handle scope stack at beginning of scope

	class HandleBeginScope : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;
	public:
		HandleBeginScope(Repository* pRepos)
<details><summary>		{</summary>
			p_Repos = pRepos;
</details>		}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("handle begin scope", *pTc);
			//if (p_Repos-&gt;scopeStack().size() == 0)
			//  Repository::Demo::write("\n--- empty stack ---");

			ASTNode* pElem = new ASTNode;
			pElem-&gt;type_ = "anonymous";
			pElem-&gt;name_ = "none";
			pElem-&gt;package_ = p_Repos-&gt;package();
			pElem-&gt;startLineCount_ = p_Repos-&gt;lineCount();
			pElem-&gt;endLineCount_ = 1;
			pElem-&gt;path_ = p_Repos-&gt;currentPath();
			/*
			* make this ASTNode child of ASTNode on stack top
			* then push onto stack
			*/
			p_Repos-&gt;AST().add(pElem);
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// rule to detect end of scope

	class EndScope : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Test end scope", *pTc);


			//std::string debug = pTc-&gt;show();

</details>			if (pTc-&gt;find("}") &lt; pTc-&gt;length())
<details><summary>			{</summary>
				doActions(pTc);
				return IRule::Stop;
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to handle scope stack at end of scope

	class HandleEndScope : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;
	public:
		using Dbug = Logging::StaticLogger&lt;2&gt;;

		HandleEndScope(Repository* pRepos)
<details><summary>		{</summary>
			p_Repos = pRepos;
</details>		}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle end scope", *pTc);

			//if (p_Repos-&gt;scopeStack().size() == 0)
			//std::string debug = pElem-&gt;name_;

			if (p_Repos-&gt;scopeStack().size() == 0)
				return;

			ASTNode* pElem = p_Repos-&gt;AST().pop();

			pElem-&gt;endLineCount_ = p_Repos-&gt;lineCount();
			if (pElem-&gt;type_ == "class" || pElem-&gt;type_ == "struct")
				(pElem-&gt;endLineCount_)++;

			p_Repos-&gt;currentAccess() = Access::priv;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// rule to detect access for C++

	class DetectAccessSpecifier : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Test access spec", *pTc);

			Repository* pRepo = Repository::getInstance();
			if (pRepo-&gt;language() != Language::Cpp)
				return IRule::Continue;

			size_t pos = pTc-&gt;find(":");
			if (0 &lt; pos && pos &lt; pTc-&gt;length())
<details><summary>			{</summary>
				const std::string tok = (*pTc)[pos - 1];
				if (tok == "public" || tok == "protected" || tok == "private")
<details><summary>				{</summary>
					doActions(pTc);
					return IRule::Stop;
</details>				}
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to handle access specifier

	class HandleAccessSpecifier : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;

	public:
		HandleAccessSpecifier(Repository* pRepos)
<details><summary>		{</summary>
			p_Repos = pRepos;
</details>		}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle access spec: ", *pTc);

			std::string tok = (*pTc)[pTc-&gt;length() - 2];
			Access& access = p_Repos-&gt;currentAccess();
			if (tok == "public")
				access = Access::publ;
			else if (tok == "protected")
				access = Access::prot;
			else
				access = Access::priv;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// rule to detect preprocessor statements

	class PreprocStatement : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Test preproc statement: ", *pTc);

			//std::string debug = pTc-&gt;show();

			if (pTc-&gt;find("#") &lt; pTc-&gt;length())
<details><summary>			{</summary>
				doActions(pTc);
				return IRule::Stop;
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to add semiexp to scope stack top statements_

	class HandlePreprocStatement : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;

	public:
		HandlePreprocStatement(Repository* pRepos)
<details><summary>		{</summary>
			p_Repos = pRepos;
</details>		}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle preproc statement: ", *pTc);

			Scanner::ITokCollection* pClone = pTc-&gt;clone();
			ASTNode* pElem = p_Repos-&gt;scopeStack().top();
			pElem-&gt;statements_.push_back(pClone);

			GrammarHelper::showParse("Preproc Stmt", *pTc);
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// rule to detect namespace statements

	class NamespaceDefinition : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Test namespace definition: ", *pTc);

			const Scanner::ITokCollection& tc = *pTc;
<details><summary>			if (tc[tc.length() - 1] == "{")</summary>
<details><summary>			{</summary>
				size_t len = tc.find("namespace");
				if (len &lt; tc.length())
<details><summary>				{</summary>
					doActions(pTc);
					return IRule::Stop;
</details>				}
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to add namespace info to scope stack top

	class HandleNamespaceDefinition : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;

	public:
		HandleNamespaceDefinition(Repository* pRepos)
<details><summary>		{</summary>
			p_Repos = pRepos;
</details>		}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle namespace definition: ", *pTc);

			ASTNode* top = p_Repos-&gt;scopeStack().top();
		
			std::string name = (*pTc)[pTc-&gt;find("namespace") + 1];
			top-&gt;type_ = "namespace";
			top-&gt;name_ = name;
			top-&gt;package_ = p_Repos-&gt;package();
			//p_Repos-&gt;setnsname = name;
			//p_Repos-&gt;AST().typeMap()[name] = top;
			GrammarHelper::showParse("namespace def", *pTc);
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// rule to detect class statements

	class ClassDefinition : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Test class definition: ", *pTc);

			const Scanner::ITokCollection& tc = *pTc;
<details><summary>			if (tc[tc.length() - 1] == "{")</summary>
<details><summary>			{</summary>
				size_t len = tc.find("class");
				if (len &lt; tc.length())
<details><summary>				{</summary>
					doActions(pTc);
					return IRule::Stop;
</details>				}
				len = tc.find("interface");
				if (len &lt; tc.length())
<details><summary>				{</summary>
					doActions(pTc);
					return IRule::Stop;
</details>				}
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to add class info to scope stack top

	class HandleClassDefinition : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;

	public:
		HandleClassDefinition(Repository* pRepos)
<details><summary>		{</summary>
			p_Repos = pRepos;
</details>		}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle class definition: ", *pTc);

			p_Repos-&gt;currentAccess() = Access::priv;

			ASTNode* top = p_Repos-&gt;scopeStack().top();
			size_t typeIndex = pTc-&gt;find("class");
			if (typeIndex &lt; pTc-&gt;length())
<details><summary>			{</summary>
				size_t nameIndex = typeIndex + 1;
				std::string name = (*pTc)[nameIndex];
				top-&gt;type_ = "class";
				top-&gt;name_ = name;
				top-&gt;package_ = p_Repos-&gt;package();
				
				p_Repos-&gt;AST().typeMap()[name] = top;
				GrammarHelper::showParse("class def", *pTc);
</details>			}
			else  // C#
<details><summary>			{</summary>
				typeIndex = pTc-&gt;find("interface");
				size_t nameIndex = typeIndex + 1;
				std::string name = (*pTc)[nameIndex];
				top-&gt;type_ = "interface";
				top-&gt;name_ = name;
				top-&gt;package_ = p_Repos-&gt;package();
				p_Repos-&gt;AST().typeMap()[name] = top;
				GrammarHelper::showParse("interface def", *pTc);
</details>			}
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// rule to detect struct statements

	class StructDefinition : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Test struct definition: ", *pTc);

			const Scanner::ITokCollection& tc = *pTc;
<details><summary>			if (tc[tc.length() - 1] == "{")</summary>
<details><summary>			{</summary>
				size_t len = tc.find("struct");
				if (len &lt; tc.length())
<details><summary>				{</summary>
					doActions(pTc);
					return IRule::Stop;
</details>				}
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to add struct info to scope stack top

	class HandleStructDefinition : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;

	public:
		HandleStructDefinition(Repository* pRepos)
<details><summary>		{</summary>
			p_Repos = pRepos;
</details>		}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle struct definition: ", *pTc);

			p_Repos-&gt;currentAccess() = Access::publ;

			ASTNode* top = p_Repos-&gt;scopeStack().top();

			std::string name = (*pTc)[pTc-&gt;find("struct") + 1];
			top-&gt;type_ = "struct";
			top-&gt;name_ = name;
			top-&gt;package_ = p_Repos-&gt;package();
			p_Repos-&gt;AST().typeMap()[name] = top;

			GrammarHelper::showParse("struct def", *pTc);
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// rule to detect C++ function definitions

	class CppFunctionDefinition : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			Repository* pRepo = Repository::getInstance();
			if (pRepo-&gt;language() != Language::Cpp)
				return IRule::Continue;

			GrammarHelper::showParseDemo("Test C++ function definition: ", *pTc);

			const Scanner::ITokCollection& tc = *pTc;
			std::string debug = pTc-&gt;show();

<details><summary>			if (tc[tc.length() - 1] == "{")</summary>
<details><summary>			{</summary>
				if (GrammarHelper::isFunction(*pTc))
<details><summary>				{</summary>
					doActions(pTc);
					return IRule::Stop;
</details>				}
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to add function info to scope stack top

	class HandleCppFunctionDefinition : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;

	public:
		HandleCppFunctionDefinition(Repository* pRepos)
<details><summary>		{</summary>
			p_Repos = pRepos;
</details>		}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle C++ function definition: ", *pTc);
			ASTNode* top = p_Repos-&gt;scopeStack().top();
			size_t nameIndex = pTc-&gt;find("(") - 1;
			std::string name = (*pTc)[nameIndex];
			if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~")
<details><summary>			{</summary>
				--nameIndex;
				name = "~" + name;
</details>			}
			top-&gt;type_ = "function";
			top-&gt;name_ = name;
			top-&gt;package_ = p_Repos-&gt;package();
			GrammarHelper::showParse("function def", *pTc);
			size_t operIndex = pTc-&gt;find("operator");
			if (operIndex &lt; pTc-&gt;length())
<details><summary>			{</summary>
				name = "operator" + (*pTc)[operIndex + 1] + (*pTc)[operIndex + 2];
				top-&gt;name_ = name;
				nameIndex = operIndex;
</details>			}
			if (nameIndex &gt; 1 && (*pTc)[nameIndex - 1] == "::")
<details><summary>			{std::string className = (*pTc)[nameIndex - 2];</summary>
				if (className == "&gt;")
<details><summary>				{</summary>
					size_t startParam = GrammarHelper::findLast(*pTc, "&lt;");
					if (0 &lt; startParam && startParam &lt; pTc-&gt;length())
						className = (*pTc)[startParam - 1];
</details>				}
				
				ASTNode* pClassNode = p_Repos-&gt;AST().find(className);
				if (pClassNode == nullptr)
					return;
				ASTNode* pFunctNode = p_Repos-&gt;scopeStack().top();
				ASTNode* pParentNode = p_Repos-&gt;scopeStack().predOfTop();
				pFunctNode-&gt;parenttype_ = pClassNode-&gt;type_; // change parent type to correct type 
				pParentNode-&gt;children_.pop_back();           // unlink function
				pClassNode-&gt;children_.push_back(pFunctNode); // relink function
</details>				return;}
			std::string packageName = p_Repos-&gt;package();
			std::string ext = FileSystem::Path::getExt(packageName);
			size_t posBracket = pTc-&gt;find("[");
<details><summary>			size_t posBrace = pTc-&gt;find("{");</summary>
			if (posBracket &lt; posBrace && posBrace &lt; pTc-&gt;length())
<details><summary>			{</summary>
				std::string name;
				for (size_t i = posBracket; i &lt; posBrace; ++i)
					name += (*pTc)[i];
				top-&gt;name_ = name;
</details>				top-&gt;type_ = "lambda";}}};

	///////////////////////////////////////////////////////////////
	// rule to detect C# function definitions

	class CSharpFunctionDefinition : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			//std::string debug = pTc-&gt;show();

			Repository* pRepo = Repository::getInstance();
			if (pRepo-&gt;language() != Language::CSharp)
				return IRule::Continue;

			GrammarHelper::showParseDemo("Test C# function definition: ", *pTc);

			const Scanner::ITokCollection& tc = *pTc;
<details><summary>			if (tc[tc.length() - 1] == "{")</summary>
<details><summary>			{</summary>
				Scanner::SemiExp se;
				for (size_t i = 0; i &lt; tc.length(); ++i)
					se.push_back(tc[i]);

				if (GrammarHelper::isFunction(se))
<details><summary>				{</summary>
					std::string debug = se.show();
					doActions(&se);
					return IRule::Stop;
</details>				}
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to add function info to scope stack top

	class HandleCSharpFunctionDefinition : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;

	public:
		HandleCSharpFunctionDefinition(Repository* pRepos)
<details><summary>		{</summary>
			p_Repos = pRepos;
</details>		}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle C# function definition: ", *pTc);

			std::string debug = pTc-&gt;show();
			ASTNode* top = p_Repos-&gt;scopeStack().top();

			size_t nameIndex = pTc-&gt;find("(") - 1;
			std::string name = (*pTc)[nameIndex];

			// is function a destructor?

			if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~")
<details><summary>			{</summary>
				--nameIndex;
				name = "~" + name;
</details>			}

			top-&gt;type_ = "function";
			top-&gt;name_ = name;
			top-&gt;package_ = p_Repos-&gt;package();

			GrammarHelper::showParse("function def", *pTc);

			// is function an operator?

			size_t operIndex = pTc-&gt;find("operator");
			if (operIndex &lt; pTc-&gt;length())
<details><summary>			{</summary>
				name = "operator" + (*pTc)[operIndex + 1] + (*pTc)[operIndex + 2];
				top-&gt;name_ = name;
				nameIndex = operIndex;
</details>			}

			// is lambda?

			size_t posParen = pTc-&gt;find("(");
<details><summary>			size_t posBrace = pTc-&gt;find("{");</summary>
			size_t posEqual = pTc-&gt;find("=");
			if (posParen &lt; posBrace && posBrace &lt; pTc-&gt;length())
<details><summary>			{</summary>
				if (posEqual &lt; pTc-&gt;length() - 1 && (*pTc)[posEqual + 1] == "&gt;")
<details><summary>				{</summary>
					std::string name;
					for (size_t i = posParen; i &lt;= posBrace; ++i)
						name += (*pTc)[i];
					top-&gt;name_ = name;
					top-&gt;type_ = "lambda";
</details>				}
</details>			}
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// rule to detect control definitions

	class ControlDefinition : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Test control definition: ", *pTc);

			const Scanner::ITokCollection& tc = *pTc;
<details><summary>			if (tc[tc.length() - 1] == "{")</summary>
<details><summary>			{</summary>
				size_t len = tc.find("(");
				if (len &lt; tc.length() && GrammarHelper::isControlKeyWord(tc[len - 1]))
<details><summary>				{</summary>
					doActions(pTc);
					return IRule::Stop;
</details>				}
				else if (tc.length() &gt; 1 && GrammarHelper::isControlKeyWord(tc[tc.length() - 2]))
<details><summary>				{</summary>
					// shouldn't need this scope since all semiExps have been trimmed
					doActions(pTc);
					return IRule::Stop;
</details>				}
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to add control info to scope stack top

	class HandleControlDefinition : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;

	public:
		HandleControlDefinition(Repository* pRepos)
<details><summary>		{</summary>
			p_Repos = pRepos;
</details>		}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle control definition: ", *pTc);

			ASTNode* top = p_Repos-&gt;scopeStack().top();

			size_t nameIndex = pTc-&gt;find("(") - 1;  // if, for, while, switch, catch
			if (nameIndex == pTc-&gt;length() - 1)     // do, try - they don't have parens
				nameIndex = pTc-&gt;length() - 2;
			std::string name = (*pTc)[nameIndex];
			top-&gt;type_ = "control";
			top-&gt;name_ = name;

			GrammarHelper::showParse("control def", *pTc);
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to send semi-expression that starts a function def
	// to console

	class PrintFunction : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;
	public:
		using Rslt = Logging::StaticLogger&lt;0&gt;;

		PrintFunction(Repository* pRepos)
<details><summary>		{</summary>
			p_Repos = pRepos;
</details>		}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			std::ostringstream out;
			out &lt;&lt; "\n  FuncDef: " &lt;&lt; pTc-&gt;show().c_str();
			Rslt::write(out.str());
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to send signature of a function def to console

	class PrettyPrintFunction : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;
	public:
		using Rslt = Logging::StaticLogger&lt;0&gt;;

		PrettyPrintFunction(Repository* pRepos) : p_Repos(pRepos) {}

		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			size_t len = pTc-&gt;find(")");

			std::ostringstream out;
			out &lt;&lt; "\n\n  Pretty Stmt:    ";
			for (size_t i = 0; i &lt; len + 1; ++i)
				out &lt;&lt; (*pTc)[i] &lt;&lt; " ";
			out &lt;&lt; "\n";
			Rslt::write(out.str());
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// rule to detect C++ Declaration
	/*
	*  - Declaration ends in semicolon
	*  - has type, name, modifiers & initializers
	*  So:
	*  - strip off modifiers and initializers
	*  - if you have two things left it's a declar, else executable
	*/
	class CppDeclaration : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			Repository* pRepo = Repository::getInstance();
			if (pRepo-&gt;language() != Language::Cpp)
				return IRule::Continue;

			GrammarHelper::showParseDemo("Test C++ declaration: ", *pTc);
			std::string debug3 = pTc-&gt;show();

			Scanner::SemiExp tc;
			tc.clone(*pTc);


			if (tc.length() &gt; 0 && tc[0] == "using")
<details><summary>			{</summary>
				doActions(pTc);
				return IRule::Stop;
</details>			}

			std::string debug = tc.show();

			if (tc[tc.length() - 1] == ";" && tc.length() &gt; 2)
<details><summary>			{</summary>
				std::string nextToLast = tc[tc.length() - 2];
				if (nextToLast == "delete" || nextToLast == "default" || nextToLast == "const")
<details><summary>				{</summary>
<details><summary>					{</summary>
						// function declaration
						doActions(pTc);
						return IRule::Stop;
</details>					}
</details>				}
				std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;

				if (GrammarHelper::isDataDeclaration(tc) || GrammarHelper::isFunctionDeclaration(tc, parentType))
<details><summary>				{</summary>
					doActions(pTc);
					return IRule::Stop;
</details>				}

				if (parentType != "function")
<details><summary>				{</summary>
					// can't be executable so must be declaration

					doActions(pTc);
					return IRule::Stop;
</details>				}
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to add declaration info to scope stack top

	class HandleCppDeclaration : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;

	public:
		HandleCppDeclaration(Repository* pRepos) : p_Repos(pRepos) {}
		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle C++ declaration: ", *pTc);
			ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top();
			size_t nameIndex = pTc-&gt;find("typedef");
<details><summary>			if (nameIndex &lt; pTc-&gt;length()){</summary>
				ASTNode* pElem = new ASTNode;
				pElem-&gt;type_ = "Typedef";
				pElem-&gt;name_ = (*pTc)[pTc-&gt;length()-2];
				pElem-&gt;package_ = p_Repos-&gt;package();
				pElem-&gt;startLineCount_ = p_Repos-&gt;lineCount();
				pElem-&gt;endLineCount_ = 1;
				pElem-&gt;path_ = p_Repos-&gt;currentPath();
				pCurrNode-&gt;children_.push_back(pElem);
				return;
</details>			}
			Scanner::SemiExp se;
			se.clone(*pTc);
			GrammarHelper::removeComments(se);
<details><summary>			if (se[0] == "using"){</summary>
<details><summary>				if (se[2] == "=") {</summary>
					ASTNode* pElem = new ASTNode;
					pElem-&gt;type_ = "alias";
					pElem-&gt;name_ = (*pTc)[1];
					pElem-&gt;package_ = p_Repos-&gt;package();
					pElem-&gt;startLineCount_ = p_Repos-&gt;lineCount();
					pElem-&gt;endLineCount_ = 1;
					pElem-&gt;path_ = p_Repos-&gt;currentPath();
					if(pCurrNode-&gt;type_!="class" && pCurrNode-&gt;type_!="struct")
					pCurrNode-&gt;children_.push_back(pElem);
					return;
</details>				}
				GrammarHelper::showParse("using declar", *pTc);
				return;
</details>			}
			DeclarationNode declNode;
			declNode.access_ = p_Repos-&gt;currentAccess();
			declNode.pTc = pTc-&gt;clone();
			declNode.package_ = p_Repos-&gt;package();
			declNode.line_ = p_Repos-&gt;lineCount();
<details><summary>			if (GrammarHelper::isDataDeclaration(se)){</summary>
				declNode.declType_ = DeclType::dataDecl;
				pCurrNode-&gt;decl_.push_back(declNode);
				GrammarHelper::showParse("data declar", *pTc);
</details>			}
<details><summary>			else{</summary>
				declNode.declType_ = DeclType::functionDecl;
				pCurrNode-&gt;decl_.push_back(declNode);
				GrammarHelper::showParse("function declar", *pTc);
</details>			}}};

	///////////////////////////////////////////////////////////////
	// rule to detect C# Declaration
	/*
	*  - Declaration ends in semicolon
	*  - has type, name, modifiers & initializers
	*  So:
	*  - strip of modifiers and initializers
	*  - if you have two things left it's a declar, else executable
	*/
	class CSharpDeclaration : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			Repository* pRepo = Repository::getInstance();
			if (pRepo-&gt;language() != Language::CSharp)
				return IRule::Continue;

			GrammarHelper::showParseDemo("Test C# declaration: ", *pTc);

			std::string debug = pTc-&gt;show();

			Access access = pRepo-&gt;currentAccess();
			bool isPublic = false;
			std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;

			if (pTc-&gt;find("public") &lt; pTc-&gt;length() && parentType != "function")
<details><summary>			{</summary>
				isPublic = true;
				pRepo-&gt;currentAccess() = Access::publ;
</details>			}

			const Scanner::ITokCollection& tc = *pTc;
			if (tc.length() &gt; 0 && tc[0] == "using")
<details><summary>			{</summary>
				doActions(pTc);
				pRepo-&gt;currentAccess() = access;
				return IRule::Stop;
</details>			}

			Scanner::SemiExp se;
			se.clone(*pTc);

			if (GrammarHelper::isDataDeclaration(se))
<details><summary>			{</summary>
				doActions(pTc);
				pRepo-&gt;currentAccess() = access;
				return IRule::Stop;
</details>			}

			if (GrammarHelper::isFunctionDeclaration(se, parentType))
<details><summary>			{</summary>
				doActions(pTc);
				pRepo-&gt;currentAccess() = access;
				return IRule::Stop;
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to add declaration info to scope stack top

	class HandleCSharpDeclaration : public IAction
<details><summary>	{</summary>
		Repository* p_Repos;

	public:
		HandleCSharpDeclaration(Repository* pRepos) : p_Repos(pRepos) {}

		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle C# declaration: ", *pTc);

			// store declaration info in ASTNode

			ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top();
			DeclarationNode declNode;
			declNode.access_ = p_Repos-&gt;currentAccess();
			declNode.pTc = pTc-&gt;clone();
			declNode.package_ = p_Repos-&gt;package();
			declNode.line_ = p_Repos-&gt;lineCount();

			Scanner::SemiExp se;
			se.clone(*pTc);
			GrammarHelper::removeComments(se);

			if (se[0] == "using")
<details><summary>			{</summary>
				declNode.declType_ = DeclType::usingDecl;
				pCurrNode-&gt;decl_.push_back(declNode);

				GrammarHelper::showParse("using declar", *pTc);
				return;
</details>			}
			//std::string debug = se.show();

			std::string parentType = p_Repos-&gt;scopeStack().top()-&gt;type_;

			if (GrammarHelper::isFunctionDeclaration(se, parentType))
<details><summary>			{</summary>
				std::string debug = se.show();
				Access adebug = declNode.access_;
				declNode.declType_ = DeclType::functionDecl;
				pCurrNode-&gt;decl_.push_back(declNode);
				GrammarHelper::showParse("function declar", *pTc);
</details>			}
			else
<details><summary>			{</summary>
				std::string debug = se.show();
				Access adebug = declNode.access_;
				declNode.declType_ = DeclType::dataDecl;
				pCurrNode-&gt;decl_.push_back(declNode);
				GrammarHelper::showParse("data declar", *pTc);
</details>			}
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// rule to detect C++ Executable

	class CppExecutable : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			Repository* pRepo = Repository::getInstance();
			if (pRepo-&gt;language() != Language::Cpp)
				return IRule::Continue;

			GrammarHelper::showParseDemo("Test C++ executable: ", *pTc);

			Scanner::SemiExp tc;
			tc.clone(*pTc);

			if (tc[tc.length() - 1] == ";" && tc.length() &gt; 2)
<details><summary>			{</summary>
				GrammarHelper::removeFunctionArgs(tc);
				GrammarHelper::condenseTemplateTypes(tc);

				// remove modifiers, comments, newlines, returns, and initializers

				Scanner::SemiExp se;
				for (size_t i = 0; i &lt; tc.length(); ++i)
<details><summary>				{</summary>
					if (GrammarHelper::isQualifierKeyWord(tc[i]))
						continue;
					if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return")
						continue;
					if (tc[i] == "=" || tc[i] == ";")
<details><summary>					{</summary>
						se.push_back(";");
						break;
</details>					}
					else
						se.push_back(tc[i]);
</details>				}
				if (se.length() != 3)  // not a declaration
<details><summary>				{</summary>
					doActions(pTc);
					return IRule::Stop;
</details>				}
</details>			}
			return IRule::Continue;
</details>		}
</details>	};

	///////////////////////////////////////////////////////////////
	// action to display C++ executable info

	class HandleCppExecutable : public IAction
<details><summary>	{</summary>
		Repository* p_Repo;

	public:
		HandleCppExecutable(Repository* pRepo) : p_Repo(pRepo) {}

		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle C++ executable: ", *pTc);

			GrammarHelper::showParse("executable", *pTc);
</details>		}
</details>	};
	///////////////////////////////////////////////////////////////
	// rule to detect C# Executable

	class CSharpExecutable : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			Repository* pRepo = Repository::getInstance();
			if (pRepo-&gt;language() != Language::CSharp)
				return IRule::Continue;

			GrammarHelper::showParseDemo("Test C# executable: ", *pTc);

			const Scanner::ITokCollection& in = *pTc;
			Scanner::SemiExp tc;
			for (size_t i = 0; i &lt; in.length(); ++i)
				tc.push_back(in[i]);

			if (tc[tc.length() - 1] == ";" && tc.length() &gt; 2)
<details><summary>			{</summary>
				GrammarHelper::removeFunctionArgs(tc);
				GrammarHelper::condenseTemplateTypes(tc);

				// remove modifiers, comments, newlines, returns, and initializers

				Scanner::SemiExp se;
				for (size_t i = 0; i &lt; tc.length(); ++i)
<details><summary>				{</summary>
					if (GrammarHelper::isQualifierKeyWord(tc[i]))
						continue;
					if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return")
						continue;
					if (tc[i] == "=" || tc[i] == ";")
<details><summary>					{</summary>
						se.push_back(";");
						break;
</details>					}
					else
						se.push_back(tc[i]);
</details>				}
				if (se.length() != 3)  // not a declaration
<details><summary>				{</summary>
					doActions(pTc);
					return IRule::Stop;
</details>				}
</details>			}
			return IRule::Continue;
</details>		}
</details>	};
	///////////////////////////////////////////////////////////////
	// action to display C# executable info

	class HandleCSharpExecutable : public IAction
<details><summary>	{</summary>
		Repository* p_Repo;

	public:
		HandleCSharpExecutable(Repository* pRepo) : p_Repo(pRepo) {}

		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle C# executable: ", *pTc);

			Scanner::SemiExp se;
			se.clone(*pTc);
			GrammarHelper::removeComments(se);

			GrammarHelper::showParse("executable", se);
</details>		}
</details>	};
	///////////////////////////////////////////////////////////////
	// default rule
	// - this is here to catch any SemiExp that didn't parse
	// - We don't have rule for enums, so they are caugth here

	class Default : public IRule
<details><summary>	{</summary>
	public:
		bool doTest(const Scanner::ITokCollection* pTc) override

<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Test default: ", *pTc);

			doActions(pTc);  // catches everything
			return IRule::Stop;
</details>		}
</details>	};
	///////////////////////////////////////////////////////////////
	// action to display default info

	class HandleDefault : public IAction
<details><summary>	{</summary>
		Repository* p_Repo;

	public:
<details><summary>		HandleDefault(Repository* pRepo) : p_Repo(pRepo) {</summary>
			//p_Repo = pRepo;
</details>		}

		void doAction(const Scanner::ITokCollection* pTc) override
<details><summary>		{</summary>
			GrammarHelper::showParseDemo("Handle default: ", *pTc);
			GrammarHelper::showParse("default: ", *pTc);
			std::string debug = pTc-&gt;show();
			ASTNode* top = p_Repo-&gt;scopeStack().top();
			
			size_t nameIndex = pTc-&gt;find("enum");
			//= pTc-&gt;find("enum");
			
			if (top-&gt;name_ == "none" && top-&gt;type_=="anonymous" &&nameIndex==0)
<details><summary>			{</summary>
				
				nameIndex = pTc-&gt;find("enum");
				std::string name = (*pTc)[nameIndex + 1];
				top-&gt;type_ = "enum";
				top-&gt;name_ = name;
				
				//p_Repo-&gt;AST().add(top);
</details>			}
			
			//p_Repo-&gt;AST().typeMap()[name] = top;

</details>		}
</details>	};
</details>}
#endif
</pre></body></html>
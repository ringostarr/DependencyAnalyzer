<!DOCTYPE html><html><head>
<!-------------HTML Prologue------------!>
<!---Published By: Akshay , 708 S Beech Street , Syracuse .--!>
<!----------------------(315)-289-0056----------------------!>
<!----Package Name:C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\FileMgr\FileSystem.cpp-----!>
<!-------Published on :04:04:2017 15:34:40-----!>
<link rel=stylesheet type=text/css href="./../Stylesheet.css"/></head> <div class = indent><h4>Dependencies:</h4><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\Executive.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\oodp26\Executive.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\FileMgr\FileSystem.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\FileMgr\FileSystem.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\CppProperties\CppProperties.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\CppProperties\CppProperties.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\FileMgr\FileMgr.h.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\FileMgr\FileMgr.h</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\XmlDocument\XmlElement.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\XmlDocument\XmlElement.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Cpp11-BlockingQueue\Cpp11-BlockingQueue.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\Cpp11-BlockingQueue\Cpp11-BlockingQueue.cpp</a><br><a href = "C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\GrammerHelpers\GrammerHelpers.cpp.htm">C:\Users\Ringo\Documents\Visual Studio 2017\Projects\oodp26\GrammerHelpers\GrammerHelpers.cpp</a><br> </div></hr><pre>/////////////////////////////////////////////////////////////////////////////
// FileSystem.cpp - Support file and directory operations                  //
// ver 2.6                                                                 //
// ----------------------------------------------------------------------- //
// copyright © Jim Fawcett, 2012                                           //
// All rights granted provided that this notice is retained                //
// ----------------------------------------------------------------------- //
// Language:    Visual C++, Visual Studio 2010                             //
// Platform:    Dell XPS 8300, Core i7, Windows 7 SP1                      //
// Application: Summer Projects, 2012                                      //
// Author:      Jim Fawcett, CST 4-187, Syracuse University                //
//              (315) 443-3948, jfawcett@twcny.rr.com                      //
/////////////////////////////////////////////////////////////////////////////

//#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;utility&gt;
#include &lt;cctype&gt;
#include &lt;locale&gt;
#include "FileSystem.h"

using namespace FileSystem;

/////////////////////////////////////////////////////////
// helper FileSystemSearch

class FileSystemSearch
<details><summary>{</summary>
public:
	FileSystemSearch();
	~FileSystemSearch();
	std::string firstFile(const std::string& path = ".", const std::string& pattern = "*.*");
	std::string nextFile();
	std::string firstDirectory(const std::string& path = ".", const std::string& pattern = "*.*");
	std::string nextDirectory();
	void close();
private:
	HANDLE hFindFile;
	WIN32_FIND_DATAA FindFileData;
	WIN32_FIND_DATAA* pFindFileData;
</details>};

FileSystemSearch::FileSystemSearch() : pFindFileData(&FindFileData) {}
FileSystemSearch::~FileSystemSearch() { ::FindClose(hFindFile); }
void FileSystemSearch::close() { ::FindClose(hFindFile); }

//----&lt; block constructor taking array iterators &gt;-------------------------

Block::Block(Byte* beg, Byte* end) : bytes_(beg, end) {}

//----&lt; push back block byte &gt;---------------------------------------------

void Block::push_back(Byte b)
<details><summary>{</summary>
	bytes_.push_back(b);
</details>}
//----&lt; non-const indexer &gt;------------------------------------------------

Byte& Block::operator[](size_t i)
<details><summary>{</summary>
	if (i&lt;0 || bytes_.size() &lt;= i)
		throw std::runtime_error("index out of range in Block");
	return bytes_[i];
</details>}
//----&lt; const indexer &gt;----------------------------------------------------

Byte Block::operator[](size_t i) const
<details><summary>{</summary>
	if (i&lt;0 || bytes_.size() &lt;= i)
		throw std::runtime_error("index out of range in Block");
	return bytes_[i];
</details>}
//----&lt; equality comparison &gt;----------------------------------------------

bool Block::operator==(const Block& block) const
<details><summary>{</summary>
	return bytes_ == block.bytes_;
</details>}
//----&lt; inequality comparison &gt;--------------------------------------------

bool Block::operator!=(const Block& block) const
<details><summary>{</summary>
	return bytes_ != block.bytes_;
</details>}
//----&lt; return number of bytes in block &gt;----------------------------------

size_t Block::size() const
<details><summary>{</summary>
	return bytes_.size();
</details>}

//----&lt; File constructor opens file stream &gt;-------------------------------

File::File(const std::string& filespec)
	: name_(filespec), pIStream(nullptr), pOStream(nullptr), dirn_(in), typ_(text), good_(true)
<details><summary>{</summary>
</details>}
//----&lt; File destructor closes file stream &gt;-------------------------------

File::~File()
<details><summary>{</summary>
	if (pIStream)
<details><summary>	{</summary>
		pIStream-&gt;close();
		delete pIStream;
		pIStream = nullptr;
		good_ = false;
</details>	}
	if (pOStream)
<details><summary>	{</summary>
		pOStream-&gt;close();
		delete pOStream;
		pOStream = nullptr;
		good_ = false;
</details>	}
</details>}
//----&lt; open for reading or writing &gt;--------------------------------------

bool File::open(direction dirn, type typ)
<details><summary>{</summary>
	dirn_ = dirn;
	typ_ = typ;
	good_ = true;
	if (dirn == in)
<details><summary>	{</summary>
		pIStream = new std::ifstream;
		if (typ == binary)
			pIStream-&gt;open(name_.c_str(), std::ios::in | std::ios::binary);
		else
			pIStream-&gt;open(name_.c_str(), std::ios::in);
		if (!(*pIStream).good())
<details><summary>		{</summary>
			good_ = false;
			pIStream = nullptr;
			//throw std::runtime_error("\n  open for input failed in File constructor");
</details>		}
</details>	}
	else
<details><summary>	{</summary>
		pOStream = new std::ofstream;
		if (typ == binary)
			pOStream-&gt;open(name_.c_str(), std::ios::out | std::ios::binary);
		else
			pOStream-&gt;open(name_.c_str(), std::ios::out);
		if (!(*pOStream).good())
<details><summary>		{</summary>
			good_ = false;
			pOStream = nullptr;
			//throw std::runtime_error("\n  open for output failed in File constructor");
</details>		}
</details>	}
	return good_;
</details>}
//----&lt; reads one line of a text file &gt;------------------------------------

std::string File::getLine(bool keepNewLines)
<details><summary>{</summary>
	if (pIStream == nullptr || !pIStream-&gt;good())
		throw std::runtime_error("input stream not open");
	if (typ_ == binary)
		throw std::runtime_error("getting text line from binary file");
	if (dirn_ == out)
		throw std::runtime_error("reading output file");

	std::string store;
	while (true)
<details><summary>	{</summary>
		char ch = pIStream-&gt;get();
		if (!isGood())
			return store;
		if (ch == '\n')
<details><summary>		{</summary>
			if (keepNewLines)
				store += ch;
			return store;
</details>		}
		store += ch;
</details>	}
</details>}
//----&lt; read all lines of text file into one string &gt;----------------------

std::string File::readAll(bool keepNewLines)
<details><summary>{</summary>
	std::string store;
	while (true)
<details><summary>	{</summary>
		if (!isGood())
			return store;
		store += getLine(keepNewLines);
		std::locale loc;
		if (store.size() &gt; 0 && !std::isspace(store[store.size() - 1], loc))
			store += ' ';
</details>	}
	return store;
</details>}
//----&lt; writes one line of a text to a file &gt;------------------------------

void File::putLine(const std::string& s, bool wantReturn)
<details><summary>{</summary>
	if (pOStream == nullptr || !pOStream-&gt;good())
		throw std::runtime_error("output stream not open");
	if (typ_ == binary)
		throw std::runtime_error("writing text line to binary file");
	if (dirn_ == in)
		throw std::runtime_error("writing input file");
	for (size_t i = 0; i&lt;s.size(); ++i)
		pOStream-&gt;put(s[i]);
	if (wantReturn)
		pOStream-&gt;put('\n');
	pOStream-&gt;flush();
</details>}
//----&lt; reads a block of bytes from binary file &gt;--------------------------

Block File::getBlock(size_t size)
<details><summary>{</summary>
	if (pIStream == nullptr || !pIStream-&gt;good())
		throw std::runtime_error("input stream not open");
	if (typ_ != binary)
		throw std::runtime_error("reading binary from text file");
	if (dirn_ == out)
		throw std::runtime_error("reading output file");
	Block blk;
	if (pIStream)
<details><summary>	{</summary>
		for (size_t i = 0; i&lt;size; ++i)
<details><summary>		{</summary>
			Byte b;
			pIStream-&gt;get(b);
			if (pIStream-&gt;good())
				blk.push_back(b);
			else
				break;
</details>		}
</details>	}
	return blk;
</details>}
//----&lt; writes a block of bytes to binary file &gt;---------------------------

void File::putBlock(const Block& blk)
<details><summary>{</summary>
	if (pOStream == nullptr || !pOStream-&gt;good())
		throw std::runtime_error("output stream not open");
	if (typ_ != binary)
		throw std::runtime_error("writing binary to text file");
	if (dirn_ == in)
		throw std::runtime_error("writing input file");
	if (!pOStream-&gt;good())
		return;
	for (size_t i = 0; i&lt;blk.size(); ++i)
<details><summary>	{</summary>
		pOStream-&gt;put(blk[i]);
</details>	}
</details>}
//----&lt; read buffer of bytes from binary file &gt;----------------------------

size_t File::getBuffer(size_t bufLen, File::byte* buffer)
<details><summary>{</summary>
	if (pIStream == nullptr || !pIStream-&gt;good())
		throw std::runtime_error("input stream not open");
	if (typ_ != binary)
		throw std::runtime_error("reading binary from text file");
	if (dirn_ == out)
		throw std::runtime_error("reading output file");
	size_t count = 0;
	while (pIStream-&gt;good())
<details><summary>	{</summary>
		buffer[count++] = pIStream-&gt;get();
		if (count == bufLen)
			break;
</details>	}
	if (!pIStream-&gt;good())  // don't write EOF char
		--count;
	return count;
</details>}
//----&lt; write buffer of bytes to binary file &gt;-------------------------------

void File::putBuffer(size_t bufLen, File::byte* buffer)
<details><summary>{</summary>
	if (pOStream == nullptr || !pOStream-&gt;good())
		throw std::runtime_error("output stream not open");
	if (typ_ != binary)
		throw std::runtime_error("writing binary to text file");
	if (dirn_ == in)
		throw std::runtime_error("writing input file");
	if (!pOStream-&gt;good())
		return;
	size_t count = 0;
	while (pOStream-&gt;good())
<details><summary>	{</summary>
		pOStream-&gt;put(buffer[count++]);
		if (count == bufLen)
			break;
</details>	}
</details>}
//----&lt; tests for error free stream state &gt;--------------------------------

bool File::isGood()
<details><summary>{</summary>
	if (!good_)
		return false;
	if (pIStream != nullptr)
		return (good_ = pIStream-&gt;good());
	if (pOStream != nullptr)
		return (good_ = pOStream-&gt;good());
	return (good_ = false);
</details>}
//----&lt; flushes output stream to its file &gt;--------------------------------

void File::flush()
<details><summary>{</summary>
	if (pOStream != nullptr && pOStream-&gt;good())
		pOStream-&gt;flush();
</details>}
//----&lt; clears error state enabling operations again &gt;---------------------

void File::clear()
<details><summary>{</summary>
	if (pIStream != nullptr)
		pIStream-&gt;clear();
	if (pOStream != nullptr)
		pOStream-&gt;clear();
</details>}
//----&lt; close file handle &gt;------------------------------------------------

void File::close()
<details><summary>{</summary>
	File::flush();
	if (pIStream != nullptr)
<details><summary>	{</summary>
		pIStream-&gt;close();
		pIStream = nullptr;
		good_ = false;
</details>	}
	if (pOStream)
<details><summary>	{</summary>
		pOStream-&gt;close();
		pOStream = nullptr;
		good_ = false;
</details>	}
</details>}
//----&lt; file exists &gt;--------------------------------------------------

bool File::exists(const std::string& file)
<details><summary>{</summary>
	return ::GetFileAttributesA(file.c_str()) != INVALID_FILE_ATTRIBUTES;
</details>}
//----&lt; copy file &gt;----------------------------------------------------

bool File::copy(const std::string& src, const std::string& dst, bool failIfExists)
<details><summary>{</summary>
	return ::CopyFileA(src.c_str(), dst.c_str(), failIfExists) != 0;
</details>}
//----&lt; remove file &gt;--------------------------------------------------

bool File::remove(const std::string& file)
<details><summary>{</summary>
	return ::DeleteFileA(file.c_str()) != 0;
</details>}
//----&lt; constructor &gt;--------------------------------------------------

FileInfo::FileInfo(const std::string& fileSpec)
<details><summary>{</summary>
	HANDLE hFile = ::FindFirstFileA(fileSpec.c_str(), &data);
	if (hFile == INVALID_HANDLE_VALUE)
		good_ = false;
	else
		good_ = true;
</details>}
//----&lt; is passed filespec valid? &gt;------------------------------------

bool FileInfo::good()
<details><summary>{</summary>
	return good_;
</details>}
//----&lt; return file name &gt;---------------------------------------------

std::string FileInfo::name() const
<details><summary>{</summary>
	return Path::getName(data.cFileName);
</details>}
//----&lt; conversion helper &gt;--------------------------------------------

std::string FileInfo::intToString(long i)
<details><summary>{</summary>
	std::ostringstream out;
	out.fill('0');
	out &lt;&lt; std::setw(2) &lt;&lt; i;
	return out.str();
</details>}
//----&lt; return file date &gt;---------------------------------------------

std::string FileInfo::date(dateFormat df) const
<details><summary>{</summary>
	std::string dateStr, timeStr;
	FILETIME ft;
	SYSTEMTIME st;
	::FileTimeToLocalFileTime(&data.ftLastWriteTime, &ft);
	::FileTimeToSystemTime(&ft, &st);
	dateStr = intToString(st.wMonth) + '/' + intToString(st.wDay) + '/' + intToString(st.wYear);
	timeStr = intToString(st.wHour) + ':' + intToString(st.wMinute) + ':' + intToString(st.wSecond);
	if (df == dateformat)
		return dateStr;
	if (df == timeformat)
		return timeStr;
	return dateStr + " " + timeStr;
</details>}
//----&lt; return file size &gt;---------------------------------------------

size_t FileInfo::size() const
<details><summary>{</summary>
	return (size_t)(data.nFileSizeLow + (data.nFileSizeHigh &lt;&lt; 8));
</details>}
//----&lt; is type archive? &gt;---------------------------------------------

bool FileInfo::isArchive() const
<details><summary>{</summary>
	return (data.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE) != 0;
</details>}
//----&lt; is type compressed? &gt;------------------------------------------

bool FileInfo::isCompressed() const
<details><summary>{</summary>
	return (data.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) != 0;
</details>}
//----&lt; is type directory? &gt;-------------------------------------------

bool FileInfo::isDirectory() const
<details><summary>{</summary>
	return (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
</details>}
//----&lt; is type encrypted? &gt;---------------------------------------------

bool FileInfo::isEncrypted() const
<details><summary>{</summary>
	return (data.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0;
</details>}
//----&lt; is type hiddent? &gt;---------------------------------------------

bool FileInfo::isHidden() const
<details><summary>{</summary>
	return (data.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) != 0;
</details>}
//----&lt; is type normal? &gt;---------------------------------------------

bool FileInfo::isNormal() const
<details><summary>{</summary>
	return (data.dwFileAttributes & FILE_ATTRIBUTE_NORMAL) != 0;
</details>}
//----&lt; is type offline? &gt;---------------------------------------------

bool FileInfo::isOffLine() const
<details><summary>{</summary>
	return (data.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) != 0;
</details>}
//----&lt; is type readonly? &gt;--------------------------------------------

bool FileInfo::isReadOnly() const
<details><summary>{</summary>
	return (data.dwFileAttributes & FILE_ATTRIBUTE_READONLY) != 0;
</details>}
//----&lt; is type system? &gt;----------------------------------------------

bool FileInfo::isSystem() const
<details><summary>{</summary>
	return (data.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) != 0;
</details>}
//----&lt; is type temporary? &gt;-------------------------------------------

bool FileInfo::isTemporary() const
<details><summary>{</summary>
	return (data.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY) != 0;
</details>}
//----&lt; compare names alphabetically &gt;---------------------------------

bool FileInfo::operator&lt;(const FileInfo& fi) const
<details><summary>{</summary>
	return strcmp(data.cFileName, fi.data.cFileName) == -1;
</details>}
//----&lt; compare names alphabetically &gt;---------------------------------

bool FileInfo::operator==(const FileInfo& fi) const
<details><summary>{</summary>
	return strcmp(data.cFileName, fi.data.cFileName) == 0;
</details>}
//----&lt; compare names alphabetically &gt;---------------------------------

bool FileInfo::operator&gt;(const FileInfo& fi) const
<details><summary>{</summary>
	return strcmp(data.cFileName, fi.data.cFileName) == 1;
</details>}
//----&lt; compare file times &gt;-------------------------------------------

bool FileInfo::earlier(const FileInfo& fi) const
<details><summary>{</summary>
	FILETIME ft1 = data.ftLastWriteTime;
	FILETIME ft2 = fi.data.ftLastWriteTime;
	return ::CompareFileTime(&ft1, &ft2) == -1;
</details>}
//----&lt; compare file times &gt;-------------------------------------------

bool FileInfo::later(const FileInfo& fi) const
<details><summary>{</summary>
	FILETIME ft1 = data.ftLastWriteTime;
	FILETIME ft2 = fi.data.ftLastWriteTime;
	return ::CompareFileTime(&ft1, &ft2) == 1;
</details>}
//----&lt; smaller &gt;------------------------------------------------------

bool FileInfo::smaller(const FileInfo &fi) const
<details><summary>{</summary>
	return size() &lt; fi.size();
</details>}
//----&lt; larger &gt;-------------------------------------------------------

bool FileInfo::larger(const FileInfo &fi) const
<details><summary>{</summary>
	return size() &gt; fi.size();
</details>}
//----&lt; convert string to lower case chars &gt;---------------------------

std::string Path::toLower(const std::string& src)
<details><summary>{</summary>
	std::string temp;
	for (size_t i = 0; i&lt;src.length(); ++i)
		temp += tolower(src[i]);
	return temp;
</details>}
//----&lt; convert string to upper case chars &gt;---------------------------


std::string Path::toUpper(const std::string& src)
<details><summary>{</summary>
	std::string temp;
	for (size_t i = 0; i&lt;src.length(); ++i)
		temp += toupper(src[i]);
	return temp;
</details>}
//----&lt; get path from fileSpec &gt;---------------------------------------

std::string Path::getName(const std::string &fileSpec, bool withExt)
<details><summary>{</summary>
	size_t pos = fileSpec.find_last_of("/");
	if (pos &gt;= fileSpec.length())
<details><summary>	{</summary>
		pos = fileSpec.find_last_of("\\");
		if (pos &gt;= fileSpec.length())
<details><summary>		{</summary>
			// no path prepended
			if (withExt)
				return fileSpec;
			else
<details><summary>			{</summary>
				// remove ext
				size_t pos = fileSpec.find(".");
				if (pos &gt; fileSpec.size())
					return fileSpec;
				return fileSpec.substr(0, pos - 1);
</details>			}
</details>		}
</details>	}
	if (withExt)
		return fileSpec.substr(pos + 1, fileSpec.length() - pos);
	else
<details><summary>	{</summary>
		// remove ext
		size_t pos2 = fileSpec.find(".", pos);
		if (pos2 &gt; fileSpec.size())
			// no ext
			return fileSpec.substr(pos + 1);
		return fileSpec.substr(pos + 1, pos2 - pos - 1);
</details>	}
</details>}
//----&lt; get extension from fileSpec &gt;----------------------------------

std::string Path::getExt(const std::string& fileSpec)
<details><summary>{</summary>
	size_t pos1 = fileSpec.find_last_of('/');
	size_t pos2 = fileSpec.find_last_of('\\');
	size_t pos = fileSpec.find_last_of('.');
	// handle ../ or ..\\ with no extension
	if (pos1 &lt; fileSpec.length() || pos2 &lt; fileSpec.length())
<details><summary>	{</summary>
		if (pos &lt; min(pos1, pos2))
			return std::string("");
</details>	}
	// only . is extension delimiter
	if (0 &lt;= pos && pos &lt; fileSpec.length())
		return toLower(fileSpec.substr(pos + 1, fileSpec.length() - pos));
	return std::string("");
</details>}
//----&lt; get path from fileSpec &gt;---------------------------------------

std::string Path::getPath(const std::string &fileSpec)
<details><summary>{</summary>
	size_t pos = fileSpec.find_last_of("/");
	if (pos &gt;= fileSpec.length())
		pos = fileSpec.find_last_of("\\");
	if (pos &gt;= fileSpec.length())
		return ".";
	if (fileSpec.find(".", pos + 1))
		return fileSpec.substr(0, pos + 1);
	return fileSpec;
</details>}
//----&lt; get absoluth path from fileSpec &gt;------------------------------

std::string Path::getFullFileSpec(const std::string &fileSpec)
<details><summary>{</summary>
	const size_t BufSize = 256;
	char buffer[BufSize];
	char filebuffer[BufSize];  // don't use but GetFullPathName will
	char* name = filebuffer;
	::GetFullPathNameA(fileSpec.c_str(), BufSize, buffer, &name);
	return std::string(buffer);
</details>}
//----&lt; create file spec from path and name &gt;--------------------------

std::string Path::fileSpec(const std::string &path, const std::string &name)
<details><summary>{</summary>
	std::string fs;
	size_t len = path.size();
	if (path[len - 1] == '/' || path[len - 1] == '\\')
		fs = path + name;
	else
<details><summary>	{</summary>
		if (path.find("/") &lt; path.size())
			fs = path + "/" + name;
		else if (path.find("\\") &lt; path.size())
			fs = path + "\\" + name;
		else
			fs = path + "/" + name;
</details>	}
	return fs;
</details>}
//----&lt; return name of the current directory &gt;-----------------------------

std::string Directory::getCurrentDirectory()
<details><summary>{</summary>
	char buffer[MAX_PATH];
	::GetCurrentDirectoryA(MAX_PATH, buffer);
	return std::string(buffer);
</details>}
//----&lt; change the current directory to path &gt;-----------------------------

bool Directory::setCurrentDirectory(const std::string& path)
<details><summary>{</summary>
	return ::SetCurrentDirectoryA(path.c_str()) != 0;
</details>}
//----&lt; get names of all the files matching pattern (path:name) &gt;----------

std::vector&lt;std::string&gt; Directory::getFiles(const std::string& path, const std::string& pattern)
<details><summary>{</summary>
	std::vector&lt;std::string&gt; files;
	FileSystemSearch fss;
	std::string file = fss.firstFile(path, pattern);
	if (file.size() == 0)
		return files;
	files.push_back(file);
	while (true)
<details><summary>	{</summary>
		file = fss.nextFile();
		if (file.size() == 0)
			return files;
		files.push_back(file);
</details>	}
	return files;
</details>}
//----&lt; get names of all directories matching pattern (path:name) &gt;--------

std::vector&lt;std::string&gt; Directory::getDirectories(const std::string& path, const std::string& pattern)
<details><summary>{</summary>
	std::vector&lt;std::string&gt; dirs;
	FileSystemSearch fss;
	std::string dir = fss.firstDirectory(path, pattern);
	if (dir.size() == 0)
		return dirs;
	dirs.push_back(dir);
	while (true)
<details><summary>	{</summary>
		dir = fss.nextDirectory();
		if (dir.size() == 0)
			return dirs;
		dirs.push_back(dir);
</details>	}
	return dirs;
</details>}
//----&lt; create directory &gt;-------------------------------------------------

bool Directory::create(const std::string& path)
<details><summary>{</summary>
	return ::CreateDirectoryA(path.c_str(), NULL) == 0;
</details>}
//----&lt; does directory exist? &gt;--------------------------------------------

bool Directory::exists(const std::string& path)
<details><summary>{</summary>
	DWORD dwAttrib = GetFileAttributesA(path.c_str());

	return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
		(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
</details>}
//----&lt; remove directory &gt;-------------------------------------------------

bool Directory::remove(const std::string& path)
<details><summary>{</summary>
	return ::RemoveDirectoryA(path.c_str()) == 0;
</details>}
//----&lt; find first file &gt;--------------------------------------------------

std::string FileSystemSearch::firstFile(const std::string& path, const std::string& pattern)
<details><summary>{</summary>
	hFindFile = ::FindFirstFileA(Path::fileSpec(path, pattern).c_str(), pFindFileData);
	if (hFindFile != INVALID_HANDLE_VALUE)
<details><summary>	{</summary>
		if (!(pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
			return pFindFileData-&gt;cFileName;
		else
			while (::FindNextFileA(hFindFile, pFindFileData))
				if (!(pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
					return pFindFileData-&gt;cFileName;
</details>	}
	return "";
</details>}
//----&lt; find next file &gt;---------------------------------------------------

std::string FileSystemSearch::nextFile()
<details><summary>{</summary>
	while (::FindNextFileA(hFindFile, pFindFileData))
		if (!(pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
			return pFindFileData-&gt;cFileName;
	return "";
</details>}
//----&lt; find first file &gt;--------------------------------------------------

std::string FileSystemSearch::firstDirectory(const std::string& path, const std::string& pattern)
<details><summary>{</summary>
	hFindFile = ::FindFirstFileA(Path::fileSpec(path, pattern).c_str(), pFindFileData);
	if (hFindFile != INVALID_HANDLE_VALUE)
<details><summary>	{</summary>
		if (pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			return pFindFileData-&gt;cFileName;
		else
			while (::FindNextFileA(hFindFile, pFindFileData))
				if (pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
					return pFindFileData-&gt;cFileName;
</details>	}
	return "";
</details>}
//----&lt; find next file &gt;---------------------------------------------------

std::string FileSystemSearch::nextDirectory()
<details><summary>{</summary>
	while (::FindNextFileA(hFindFile, pFindFileData))
		if (pFindFileData-&gt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			return pFindFileData-&gt;cFileName;
	return "";
</details>}
//----&lt; test stub &gt;--------------------------------------------------------

#ifdef TEST_FILESYSTEM

void title(const std::string& title, char ch = '=')
<details><summary>{</summary>
	std::cout &lt;&lt; "\n  " &lt;&lt; title;
	std::cout &lt;&lt; "\n " &lt;&lt; std::string(title.size() + 2, ch);
</details>}
int main(int argc, char* argv[])
<details><summary>{</summary>
	title("Demonstrate Path Class");

	std::string fs = Path::fileSpec(".", "temp.txt");
	std::cout &lt;&lt; "\n  Path::fileSpec(\".\",\"temp.txt\") = " &lt;&lt; fs;

	std::string path = Path::getPath(fs);
	std::cout &lt;&lt; "\n  Path::getPath(\"" + fs + "\") = " &lt;&lt; path;

	std::string ffs = Path::getFullFileSpec(fs);
	std::cout &lt;&lt; "\n  Path::getFullFileSpec(\"" + fs + "\") = " &lt;&lt; ffs;

	std::string name = Path::getName(fs);
	std::cout &lt;&lt; "\n  Path::getName(\"" + fs + "\") = " &lt;&lt; name;

	std::string ext = Path::getExt(fs);
	std::cout &lt;&lt; "\n  Path::getExt(\"" + fs + "\") = " &lt;&lt; ext;

	std::string upper = Path::toUpper("temp.txt");
	std::cout &lt;&lt; "\n  Path::toUpper(\"temp.txt\") = " &lt;&lt; upper;

	std::string lower = Path::toLower("Temp.Txt");
	std::cout &lt;&lt; "\n  Path::toLower(\"Temp.Txt\") = " &lt;&lt; lower;
	std::cout &lt;&lt; std::endl;
	/*
	title("Demonstrate FileSystemSearch class");

	const size_t PathSetSize = 2;
	std::string home = ::getenv("HOMEDRIVE");
	std::string pathSet[] = { home+"\\\\", "." };
	FileSystemSearch fss;
	for(size_t i = 0; i&lt;PathSetSize; ++i)
<details><summary>	{</summary>
	std::cout &lt;&lt; "\n  searching for files on \"" &lt;&lt; pathSet[i] &lt;&lt; "\"";
	std::cout &lt;&lt; "\n " &lt;&lt; std::string(27 + pathSet[i].size(), '-');
	std::string searchPath = pathSet[i];
	std::string fileName = fss.firstFile(searchPath);
	if(fileName.size() &gt; 0)
	std::cout &lt;&lt; "\n  " &lt;&lt; fileName;
	else
	std::cout &lt;&lt; "\n  no files match search";
<details><summary>	while(true) {</summary>
	fileName = fss.nextFile();
	if(fileName.size() &gt; 0)
	std::cout &lt;&lt; "\n  " &lt;&lt; fileName;
	else
	break;
</details>	}
	std::cout &lt;&lt; std::endl;

	std::cout &lt;&lt; "\n  searching for directories on \"" &lt;&lt; pathSet[i] &lt;&lt; "\"";
	std::cout &lt;&lt; "\n " &lt;&lt; std::string(33 + pathSet[i].size(), '-');
	std::string dirName = fss.firstDirectory(searchPath);
	if(dirName.size() &gt; 0)
	std::cout &lt;&lt; "\n  " &lt;&lt; dirName;
	else
	std::cout &lt;&lt; "\n  no directories match search";
	while(true)
<details><summary>	{</summary>
	dirName = fss.nextDirectory();
	if(dirName.size() &gt; 0)
	std::cout &lt;&lt; "\n  " &lt;&lt; dirName;
	else
	break;
</details>	}
	std::cout &lt;&lt; std::endl;
</details>	}
	*/
	title("Demonstrate Directory class");

	// Display contents of current directory

	std::cout &lt;&lt; "\n  current directory is:\n    " &lt;&lt; Directory::getCurrentDirectory();
	std::cout &lt;&lt; "\n  It contains files:";
	std::vector&lt;std::string&gt; currfiles = Directory::getFiles();
	///////////////////////////////////////////////////////
	// This works too
	// std::vector&lt;std::string&gt; currfiles = d.getFiles();  
	for (size_t i = 0; i&lt;currfiles.size(); ++i)
		std::cout &lt;&lt; "\n    " &lt;&lt; currfiles[i].c_str();
	std::cout &lt;&lt; "\n  and contains directories:";
	std::vector&lt;std::string&gt; currdirs = Directory::getDirectories();
	for (size_t i = 0; i&lt;currdirs.size(); ++i)
		std::cout &lt;&lt; "\n    " &lt;&lt; currdirs[i].c_str();
	std::cout &lt;&lt; "\n";

	// Display contents of non-current directory

	std::cout &lt;&lt; "\n  .txt files residing in C:/temp are:";
	currfiles = Directory::getFiles("c:/temp/", "*.txt");

	// if we want fully qualified file names, we have to
	// set the current directory to the path on which the files
	// reside, if it isn't already so set

	std::string currDir = Directory::getCurrentDirectory();
	Directory::setCurrentDirectory("c:/temp/");
	for (size_t i = 0; i&lt;currfiles.size(); ++i)
		std::cout &lt;&lt; "\n    " &lt;&lt; Path::getFullFileSpec(currfiles[i]).c_str();
	Directory::setCurrentDirectory(currDir);

	// we have to restore the current directory so the
	// remaining tests work

	// it's probably easier just to use Path::fileSpec(path, filename)
	// like this:

	for (size_t i = 0; i&lt;currfiles.size(); ++i)
		std::cout &lt;&lt; "\n    " &lt;&lt; Path::fileSpec("c:\\temp\\", currfiles[i]).c_str();

	std::cout &lt;&lt; "\n";
	std::cout &lt;&lt; "\n  directories residing in C:/temp are:";
	currdirs = Directory::getDirectories("c:/temp/");
	for (size_t i = 0; i&lt;currdirs.size(); ++i)
		std::cout &lt;&lt; "\n    " &lt;&lt; currdirs[i].c_str();
	std::cout &lt;&lt; "\n";

	// Create directory

	title("Demonstrate FileInfo Class Operations", '=');
	std::cout &lt;&lt; "\n";

	Directory::setCurrentDirectory(".");
	std::cout &lt;&lt; "\n  current path is \"" &lt;&lt; Directory::getCurrentDirectory();

	std::string fn1;
	if (argc &gt; 1)
		fn1 = argv[1];
	else
		fn1 = "c:\\temp\\test.txt";
	FileInfo fi(fn1);

	if (fi.good())
<details><summary>	{</summary>
		std::cout &lt;&lt; "\n  name: " &lt;&lt; "\t" &lt;&lt; fi.name();
		std::cout &lt;&lt; "\n  date: " &lt;&lt; "\t" &lt;&lt; fi.date();
		std::cout &lt;&lt; "\n  date: " &lt;&lt; "\t" &lt;&lt; fi.date(FileInfo::dateformat);
		std::cout &lt;&lt; "\n  date: " &lt;&lt; "\t" &lt;&lt; fi.date(FileInfo::timeformat);
		std::cout &lt;&lt; "\n  size: " &lt;&lt; "\t" &lt;&lt; fi.size() &lt;&lt; " bytes";
		if (fi.isArchive())
			std::cout &lt;&lt; "\n  is archive";
		else
			std::cout &lt;&lt; "\n  is not archive";
		if (fi.isCompressed())
			std::cout &lt;&lt; "\n  is compressed";
		else
			std::cout &lt;&lt; "\n  is not compressed";
		if (fi.isDirectory())
			std::cout &lt;&lt; "\n  is directory";
		else
			std::cout &lt;&lt; "\n  is not directory";
		if (fi.isEncrypted())
			std::cout &lt;&lt; "\n  is encrypted";
		else
			std::cout &lt;&lt; "\n  is not encrypted";
		if (fi.isHidden())
			std::cout &lt;&lt; "\n  is hidden";
		else
			std::cout &lt;&lt; "\n  is not hidden";
		if (fi.isNormal())
			std::cout &lt;&lt; "\n  is normal";
		else
			std::cout &lt;&lt; "\n  is not normal";
		if (fi.isOffLine())
			std::cout &lt;&lt; "\n  is offline";
		else
			std::cout &lt;&lt; "\n  is not offline";
		if (fi.isReadOnly())
			std::cout &lt;&lt; "\n  is readonly";
		else
			std::cout &lt;&lt; "\n  is not readonly";
		if (fi.isSystem())
			std::cout &lt;&lt; "\n  is system";
		else
			std::cout &lt;&lt; "\n  is not system";
		if (fi.isTemporary())
			std::cout &lt;&lt; "\n  is temporary";
		else
			std::cout &lt;&lt; "\n  is not temporary";
</details>	}
	else
		std::cout &lt;&lt; "\n  filename " &lt;&lt; fn1 &lt;&lt; " is not valid in this context\n";

	std::string fn2;
	if (argc &gt; 2)
<details><summary>	{</summary>
		fn1 = argv[1];
		fn2 = argv[2];
</details>	}
	else
<details><summary>	{</summary>
		fn1 = "FileSystem.h";
		fn2 = "FileSystem.cpp";
</details>	}
	FileInfo fi1(fn1);
	FileInfo fi2(fn2);
	if (fi1.good() && fi2.good())
<details><summary>	{</summary>
		if (fi1 == fi1)
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " == " &lt;&lt; fi1.name();
		else
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " != " &lt;&lt; fi1.name();
		if (fi1 &lt; fi1)
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &lt; " &lt;&lt; fi1.name();
		else
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &gt;= " &lt;&lt; fi1.name();
		if (fi1 == fi2)
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " == " &lt;&lt; fi2.name();
		else
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " != " &lt;&lt; fi2.name();
		if (fi1 &lt; fi2)
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &lt; " &lt;&lt; fi2.name();
		else
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &gt;= " &lt;&lt; fi2.name();
		if (fi1.smaller(fi2))
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is smaller than " &lt;&lt; fi2.name();
		else
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is not smaller than " &lt;&lt; fi2.name();
		if (fi1.earlier(fi2))
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is earlier than " &lt;&lt; fi2.name();
		else
			std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is not earlier than " &lt;&lt; fi2.name();
		std::cout &lt;&lt; std::endl;
</details>	}
	else
		std::cout &lt;&lt; "\n  files " &lt;&lt; fn1 &lt;&lt; " and " &lt;&lt; fn2 &lt;&lt; " are not valid in this context\n";

	title("Demonstrate File class operations", '=');
	std::cout &lt;&lt; "\n";

	// copy binary file from one directory to another

	File me("../debug/filesystemdemo.exe");
	me.open(File::in, File::binary);
	std::cout &lt;&lt; "\n  copying " &lt;&lt; me.name().c_str() &lt;&lt; " to c:/temp";
	if (!me.isGood())
<details><summary>	{</summary>
		std::cout &lt;&lt; "\n  can't open executable\n";
		std::cout &lt;&lt; "\n  looking for:\n  ";
		std::cout &lt;&lt; Path::getFullFileSpec(me.name()) &lt;&lt; "\n";
</details>	}
	else
<details><summary>	{</summary>
		File you("c:/temp/fileSystemdemo.exe");
		you.open(File::out, File::binary);
		if (you.isGood())
<details><summary>		{</summary>
			while (me.isGood())
<details><summary>			{</summary>
				static size_t count = 0;
				Block b = me.getBlock(1024);
				you.putBlock(b);
				if (++count &lt; 10)
<details><summary>				{</summary>
					std::cout &lt;&lt; "\n    reading block of " &lt;&lt; b.size() &lt;&lt; " bytes";
					std::cout &lt;&lt; "\n    writing block of " &lt;&lt; b.size() &lt;&lt; " bytes";
</details>				}
				if (b.size() &lt; 1024)
<details><summary>				{</summary>
					std::cout &lt;&lt; "\n\n    omitted " &lt;&lt; count - 10 &lt;&lt; " blocks from display\n\n";
					std::cout &lt;&lt; "\n    reading block of " &lt;&lt; b.size() &lt;&lt; " bytes";
					std::cout &lt;&lt; "\n    writing block of " &lt;&lt; b.size() &lt;&lt; " bytes";
</details>				}
</details>			}
			std::cout &lt;&lt; "\n";
</details>		}
</details>	}

	// save some filespecs of text files in a vector for File demonstrations

	std::vector&lt;std::string&gt; files;
	if (argc == 1)
<details><summary>	{</summary>
		std::cout &lt;&lt; "\n\n  Enter, on the command line, an additional filename to process.\n";
</details>	}

	for (int i = 1; i&lt;argc; ++i)
<details><summary>	{</summary>
		files.push_back(argv[i]);
</details>	}
	files.push_back("FileSystem.cpp");                     // file not on current path
	files.push_back("../FileSystemDemo/FileSystem.cpp");   // file from project directory
	files.push_back("../FileSystemTest.txt");              // file in solution directory
	files.push_back("foobar");                             // doesn't exist

														   // open each file and display a few lines of text

	for (size_t i = 0; i&lt;files.size(); ++i)
<details><summary>	{</summary>
		File file(files[i]);
		file.open(File::in);
		if (!file.isGood())
<details><summary>		{</summary>
			std::cout &lt;&lt; "\n  Can't open file " &lt;&lt; file.name();
			std::cout &lt;&lt; "\n  Here's what the program can't find:\n  " &lt;&lt; Path::getFullFileSpec(file.name());
			continue;
</details>		}
		std::string temp = std::string("Processing file ") + files[i];
		title(temp, '-');
		for (int j = 0; j&lt;10; ++j)
<details><summary>		{</summary>
			if (!file.isGood())
				break;
			std::cout &lt;&lt; "\n  -- " &lt;&lt; file.getLine().c_str();
</details>		}
		std::cout &lt;&lt; "\n";
</details>	}
	std::cout &lt;&lt; "\n";

	// read all lines of text file into string

	title("testing File::readAll()", '-');
	std::cout &lt;&lt; "\n";
	File testAll("../FileSystemTest.txt");
	testAll.open(File::in);
	if (testAll.isGood())
<details><summary>	{</summary>
		std::string all = testAll.readAll();
		std::cout &lt;&lt; all &lt;&lt; "\n";
</details>	}
	testAll.close();

	title("testing File::readAll(true)", '-');
	std::cout &lt;&lt; "\n";
	File testAllTrue("../FileSystemTest.txt");
	testAllTrue.open(File::in);
	if (testAllTrue.isGood())
<details><summary>	{</summary>
		std::string all = testAllTrue.readAll(true);
		std::cout &lt;&lt; all &lt;&lt; "\n";
</details>	}
	testAllTrue.close();

	// test reading non-text files

	title("test reading non-text files", '-');
	std::cout &lt;&lt; "\n";
	std::string testPath = "./debug";  // run from project directory (what Visual Studio does)
	if (!Directory::exists(testPath))
		testPath = ".";                  // run from solution debug directory
	std::vector&lt;std::string&gt; testFiles = Directory::getFiles(testPath);
	for (auto file : testFiles)
<details><summary>	{</summary>
		try
<details><summary>		{</summary>
			std::string ext = Path::getExt(file);
			if (ext == "exe" || ext == "dll" || file == "run.dat")
<details><summary>			{</summary>
				/* reading binary file works, but generates a lot of garbage */
				/* I use run.dat to capture this output so including will make output confusing */

				std::cout &lt;&lt; "  skipping binary file " &lt;&lt; file &lt;&lt; "\n";
				continue;
</details>			}
			File test(file);
			test.open(File::in);  // open as text file
			std::cout &lt;&lt; "\n  processing \"" &lt;&lt; file &lt;&lt; "\"\n";
			if (test.isGood())
<details><summary>			{</summary>
				std::string text = test.readAll(true);
				std::cout &lt;&lt; text &lt;&lt; "\n";
</details>			}
			else
<details><summary>			{</summary>
				std::cout &lt;&lt; "\n  open failed\n";
</details>			}
</details>		}
		catch (std::exception& ex)
<details><summary>		{</summary>
			std::cout &lt;&lt; "\n  Exception: " &lt;&lt; ex.what() &lt;&lt; "\n";
</details>		}
</details>	}

	// read text file and write to another text file

	title("writing to c:/temp/test.txt", '-');
	File in("../FileSystemDemo/FileSystem.h");
	in.open(File::in, File::text);
	File out("c:/temp/test.txt");
	out.open(File::out, File::text);
	while (in.isGood())
<details><summary>	{</summary>
		std::string temp = in.getLine();
		//std::cout &lt;&lt; "\n  " &lt;&lt; temp.c_str();
		out.putLine(temp);
		out.putLine("\n");
</details>	}
	std::cout &lt;&lt; "\n  check c:/temp/test.txt to validate";
	std::cout &lt;&lt; "\n\n";

	// read and write buffers

	title("reading and writing buffers");
	std::cout &lt;&lt; "\n  " &lt;&lt; FileSystem::Directory::getCurrentDirectory();
	std::string fileIn = "TestFileSystem/UnitTest.h";
	std::string fileOut = "TestFileSystem/CopyOfUnitTest.h";
	File bufferIn(fileIn);
	bufferIn.open(File::in, File::binary);
	if (!bufferIn.isGood())
<details><summary>	{</summary>
		std::cout &lt;&lt; "\n  could not open \"" &lt;&lt; fileIn &lt;&lt; "\" for reading";
		return 1;
</details>	}
	else
<details><summary>	{</summary>
		std::cout &lt;&lt; "\n  opening: \"" &lt;&lt; fileIn &lt;&lt; "\" for reading";
</details>	}
	File bufferOut(fileOut);
	bufferOut.open(File::out, File::binary);
	if (!bufferOut.isGood())
<details><summary>	{</summary>
		std::cout &lt;&lt; "\n  could not open \"" &lt;&lt; fileOut &lt;&lt; "\" for writing\n\n";
		return 1;
</details>	}
	else
<details><summary>	{</summary>
		std::cout &lt;&lt; "\n  opening: \"" &lt;&lt; fileOut &lt;&lt; "\" for writing";
</details>	}
	std::cout &lt;&lt; "\n";
	const size_t bufLen = 124;
	File::byte buffer[bufLen];
	while (true)
<details><summary>	{</summary>
		size_t resultSize = bufferIn.getBuffer(bufLen, buffer);
		//std::cout &lt;&lt; "\n  reading buffer of size " &lt;&lt; resultSize &lt;&lt; " bytes";
		std::string temp1(buffer, resultSize);
		std::cout &lt;&lt; temp1;
		//std::cout &lt;&lt; "\n  writing buffer of size " &lt;&lt; resultSize &lt;&lt; "bytes";
		bufferOut.putBuffer(resultSize, buffer);
		if (resultSize &lt; bufLen || !bufferIn.isGood() || !bufferOut.isGood())
<details><summary>		{</summary>
			bufferIn.close();
			bufferOut.close();
			break;
</details>		}
</details>	}
	std::cout &lt;&lt; "\n\n";
</details>}
#endif
</pre></body></html>